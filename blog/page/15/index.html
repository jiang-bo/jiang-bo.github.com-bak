
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>非纯种程序猿</title>
  <meta name="author" content="jiang-bo">

  
  <meta name="description" content="引子 一个使用缓存进行并发控制的讨论，让我学习到成本与收益间的平衡，以及何为真正的可用性&#8230;&#8230;
防止并发有多种方式，本文只涉及使用缓存memcached控制。
并发场景：
&nbsp;&nbsp; &nbsp; 用例：SNS系统中具有高级会员资格的人发起活动。
&nbsp;& &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jiangbo.me/blog/page/15/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
   <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="非纯种程序猿" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>


  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34477986-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
</hgroup>

</header>
  <!-- <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jiangbo.me" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav> -->
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/02/27/post/">使用memcached进行并发控制</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-02-27T00:00:00+08:00" pubdate data-updated="true">Feb 27<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/02/27/post/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong><span style="font-family: mceinline;">引子</span></strong></p>
<p>
</p><p class="p2">一个使用缓存进行并发控制的讨论，让我学习到成本与收益间的平衡，以及何为真正的可用性&#8230;&#8230;</p>
<p class="p2">防止并发有多种方式，本文只涉及使用缓存memcached控制。</p>
<p class="p1" style="font-weight: bold;"><span style="font-family: mceinline;"><strong>并发场景</strong><span class="s1"><strong>：</strong></span></span></p>
<p class="p2"><strong>&nbsp;&nbsp; </strong>&nbsp; 用例：SNS系统中具有高级会员资格的人发起活动。</p>
<p class="p2">&nbsp;&nbsp; &nbsp; 业务规则：1.一个人同时只能创建一个活动。2.具有高级会员资格。</p>
<p class="p2">&nbsp;&nbsp; &nbsp; 基本流程如下：</p>
<p style="font-weight: bold;">&nbsp;</p>
<p class="p1" style="font-weight: bold;">&nbsp;</p>

<p>&nbsp;</p>
<p class="p2"><img src="http://hi.csdn.net/attachment/201102/27/0_1298804115LLTM.gif" alt="" /></p>
<p class="p1">这个流程中存在明显的并发问题，当进程A校验过会员M有资格，并且为创建过活动，但为开始执行创建操作，此时另一个进程B也进行了规则判断，顺利通过，并完成创建操作，此时A继续执行，则会产生两条M的活动。（这个并发场景很简单，很普遍）</p>
<p class="p2"><strong><span style="font-family: mceinline;">最初的解决方案：</span></strong></p>
<p class="p1">&nbsp;&nbsp; &nbsp; 计划利用memcached的add操作的原子性来控制并发，具体方式如下：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 1.申请锁：在校验是否创建过活动前，执行add操作key为memberId，如果add操作失败，则表示有另外的进程在并发的为该memberId创建活动，返回创建失败。否则表示无并发</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 2.执行创建活动</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 3.释放锁：创建活动完成后，执行delete操作，删除该memberId。</p>
<p class="p2"><strong><span style="font-family: mceinline;">问题：</span></strong></p>
<p class="p1"><strong>&nbsp;&nbsp; &nbsp;</strong> 如此实现存在一些问题：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 1.memcached中存放的值有有效期，即过期后自动失效，如add过M1后，M1失效，可以在此add成功</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 2.即使通过配置，可以使memcached永久有效，即不设有效期，memcached有容量限制，当容量不够后会进行自动替换，即有可能add过M1后，M1被其他key值置换掉，则再次add可以成功。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 3.此外，memcached是基于内存的，掉电后数据会全部丢失，导致重启后所有memberId均可重新add。</p>
<p class="p2"><strong><span style="font-family: mceinline;">应对问题：</span></strong></p>
<p class="p1">&nbsp;&nbsp; &nbsp; 针对上述的几个问题，根本原因是add操作有时效性，过期，被替换，重启，都会是原来的add操作失效。解决该问题有两个方法：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 1.采用持久化的缓存解决方法，如TT（<span class="s1">Tokyo Tyrant：</span><span class="s2">http://fallabs.com/tokyotyrant/</span>）</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 2.减轻时效性的影响，使用memcached CAS（check and set）方式。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 第一种不必解释了，很简单，原来的所有问题都是时效性惹得祸，时效性源于memcached是基于内存的，那么采用持久话存储的TT可以彻底根治这个问题。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 第二种方式需要简单介绍下：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; memcached中除了add操作是原子的，还有另外两个操作也是原子的：incr和decr，使用CAS模式即：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 1.预先在memcached中设置一个key值，假设为CREATKEY＝1</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 2.每次创建活动时，在规则校验前先get出CREATEKEY＝x；</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 3.进行规则校验</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 4.执行incr CREATEKEY操作，检验返回值是否为所期望的x＋1，如果不是，则说明在此期间有另外的进程执行了incr操作，即存在并发，放弃更新。否则</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 5.执行创建活动</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 对比这两种方法，从效果上看可以发现第一种时100％可靠的，不存在问题；第二种，可能存在误判，即本来不存在并发，却被判为并发，如缓存重启，或key值失效后，incr值可能不同于期望值，导致误判。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 但是从成本上考虑，TT是持久化的缓存解决方案，完美意味着高成本，我们必须维护持久化数据，而使用memcached的CAS方式，可以以几乎0成本的方式解决时效性问题，尽管存在一点小缺陷，但这种缺陷可以通过简单的重试即可解决。考虑实际的产出比，采用memcached的CAS方式更适合实际情况。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 成本与收益间的平衡，做科学与做工程的区别～</p>
<p class="p3">&nbsp;</p>
<p class="p1">&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/01/17/post/">Zero-Copy&amp;sendfile浅析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-17T00:00:00+08:00" pubdate data-updated="true">Jan 17<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/01/17/post/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>一、典型<span lang="EN-US">IO</span>调用的问题</strong><span lang="EN-US"><br /></span>一个典型的<span lang="EN-US">web</span>服务器传送静态文件（如<span lang="EN-US">CSS</span>，<span lang="EN-US">JS</span>，图片等）的过程如下：<span lang="EN-US"><br /><em><br />read(file, tmp_buf, len);<br />write(socket, tmp_buf, len);</em><br /><br /></span>首先调用<span lang="EN-US">read</span>将文件从磁盘读取到<span lang="EN-US">tmp_buf</span>，然后调用<span lang="EN-US">write</span>将<span lang="EN-US">tmp_buf</span>写入到<span lang="EN-US">socket</span>，在这过程中会出现四次数据<span lang="EN-US"> copy</span>，过程如图<span lang="EN-US">1</span>所示</p>
<p style="text-align: center;"><img src="http://hi.csdn.net/attachment/201101/17/0_12952361353NK2.gif" alt="" /></p>
<p style="text-align: center;">图1</p>
<p style="text-align: left;">&nbsp;</p>
<p><span lang="EN-US">1</span><span>。当调用</span><span lang="EN-US">read</span><span>系统调用时，通过</span><span lang="EN-US">DMA</span><span>（</span><span lang="EN-US">Direct Memory Access</span><span>）将数据</span><span lang="EN-US">copy</span><span>到内核模式</span><span lang="EN-US"><br /></span><span lang="EN-US">2</span><span>。然后由</span><span lang="EN-US">CPU</span><span>控制将内核模式数据</span><span lang="EN-US">copy</span><span>到用户模式下的</span><span lang="EN-US"> buffer</span><span>中</span><span lang="EN-US"><br /></span><span lang="EN-US">3</span><span>。</span><span lang="EN-US">read</span><span>调用完成后，</span><span lang="EN-US">write</span><span>调用首先将用户模式下</span><span lang="EN-US"> buffer</span><span>中的数据</span><span lang="EN-US">copy</span><span>到内核模式下的</span><span lang="EN-US">socket buffer</span><span>中</span><span lang="EN-US"><br /></span><span lang="EN-US">4</span><span>。最后通过</span><span lang="EN-US">DMA copy</span><span>将内核模式下的</span><span lang="EN-US">socket buffer</span><span>中的数据</span><span lang="EN-US">copy</span><span>到网卡设备中传送。</span></p>
<p><span><span>从上面的过程可以看出，数据白白从内核模式到用户模式走了一</span><span> </span><span>圈，浪费了两次</span><span lang="EN-US">copy</span><span>，而这两次</span><span lang="EN-US">copy</span><span>都是</span><span lang="EN-US">CPU copy</span><span>，即占用</span><span lang="EN-US">CPU</span><span>资源。</span></span></p>
<p>&nbsp;</p>
<p><strong><span lang="EN-US">二、Zero-Copy&amp;Sendfile()</span></strong><span lang="EN-US"><br /></span><span lang="EN-US">Linux 2.1</span><span>版本内核引入了</span><span lang="EN-US">sendfile</span><span>函数，用于将文件通过</span><span lang="EN-US">socket</span><span>传送。</span><span lang="EN-US"><br /></span><em><span lang="EN-US">sendfile(socket, file, len);</span></em><span lang="EN-US"><br /></span><span>该函数通过一次系统调用完成了文件的传送，减少了原来</span><span lang="EN-US"> read/write</span><span>方式的模式切换。此外更是减少了数据的</span><span lang="EN-US">copy</span><span>，</span><span lang="EN-US">sendfile</span><span>的详细过程图</span><span lang="EN-US">2</span><span>所示：</span></p>
<p style="text-align: center;"><span><img src="http://hi.csdn.net/attachment/201101/17/0_1295236150Tf0Z.gif" alt="" /></span></p>
<p style="text-align: center;"><span>图2</span></p>
<p style="text-align: left;"><span><span>通过</span><span lang="EN-US">sendfile</span><span>传送文件只需要一次系统调用，当调用</span><span lang="EN-US"> sendfile</span><span>时：</span><span lang="EN-US"><br /></span><span lang="EN-US">1</span><span>。首先通过</span><span lang="EN-US">DMA copy</span><span>将数据从磁盘读取到</span><span lang="EN-US">kernel buffer</span><span>中</span><span lang="EN-US"><br /></span><span lang="EN-US">2</span><span>。然后通过</span><span lang="EN-US">CPU copy</span><span>将数据从</span><span lang="EN-US">kernel buffer copy</span><span>到</span><span lang="EN-US">sokcet buffer</span><span>中</span><span lang="EN-US"><br /></span><span lang="EN-US">3</span><span>。最终通过</span><span lang="EN-US">DMA copy</span><span>将</span><span lang="EN-US">socket buffer</span><span>中数据</span><span lang="EN-US">copy</span><span>到网卡</span><span lang="EN-US">buffer</span><span>中发送</span><span lang="EN-US"><br /></span><span lang="EN-US">sendfile</span><span>与</span><span lang="EN-US">read/write</span><span>方式相比，少了</span><span> </span><span>一次模式切换一次</span><span lang="EN-US">CPU copy</span><span>。但是从上述过程中也可以发现从</span><span lang="EN-US">kernel buffer</span><span>中将数据</span><span lang="EN-US">copy</span><span>到</span><span lang="EN-US">socket buffer</span><span>是没必要的。</span></span></p>
<p style="text-align: left;"><span><span><span>为此，</span><span lang="EN-US">Linux2.4</span><span>内核对</span><span lang="EN-US">sendfile</span><span>做了改进，如图</span><span lang="EN-US">3</span><span>所示</span></span></span></p>
<p style="text-align: center;"><span><span><span><img src="http://hi.csdn.net/attachment/201101/17/0_1295236158Tr8t.gif" alt="" /></span></span></span></p>
<p style="text-align: center;">图3</p>
<p style="text-align: left;">改进后的处理过程如下：<span lang="EN-US"><br />1</span>。<span lang="EN-US">DMA copy</span>将磁盘数据<span lang="EN-US">copy</span>到<span lang="EN-US">kernel buffer</span>中<span lang="EN-US"><br />2</span>。向<span lang="EN-US">socket buffer</span>中追加当前要发送的数据在<span lang="EN-US">kernel buffer</span>中的位置和偏移量<span lang="EN-US"><br />3</span>。<span lang="EN-US">DMA gather copy</span>根据<span lang="EN-US">socket buffer</span>中的位置和偏移量直接将<span lang="EN-US">kernel buffer</span>中的数据<span lang="EN-US">copy</span>到网卡上。<span lang="EN-US"><br /></span>经过上述过程，数据只经过了<span lang="EN-US">2</span>次<span lang="EN-US">copy</span>就从磁盘传送出去了。<span lang="EN-US"><br /></span>（可能有人要纠结<span lang="EN-US">&ldquo;</span>不是说<span lang="EN-US">Zero</span>－<span lang="EN-US">Copy</span>么？怎么还有两次<span lang="EN-US">copy</span>啊<span lang="EN-US">&rdquo;</span>，事实上这个<span lang="EN-US">Zero copy</span>是针对内核来讲的，数据在内核模式下是<span lang="EN-US">Zero</span>－<span lang="EN-US">copy</span>的。话说回来，文件本身在瓷盘上要真是完全<span lang="EN-US">Zero</span>－<span lang="EN-US">copy</span>就能传送，那才见鬼了 呢）。<span lang="EN-US"><br /></span>当前许多高性能<span lang="EN-US">http server</span>都引入了<span lang="EN-US">sendfile</span>机制，如<span lang="EN-US">nginx</span>，<span lang="EN-US">lighttpd</span>等。<span lang="EN-US"><br /><br /><strong>三、Java NIO</strong></span><strong>中的<span lang="EN-US">transferTo()</span></strong><span lang="EN-US"><br />Java NIO</span>中<span lang="EN-US"><br /><em>FileChannel.transferTo(long position, long count, WriteableByteChannel target)</em><br /></span>方法将当前通道中的数据传送到目标通道<span lang="EN-US">target</span>中，在支持<span lang="EN-US">Zero-Copy</span>的<span lang="EN-US">linux</span>系统中，<span lang="EN-US">transferTo()</span>的实现依赖于<span lang="EN-US"> sendfile()</span>调用。</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><strong>四、参考文档<span lang="EN-US"><br /></span>《<span lang="EN-US">Zero Copy I: User-Mode Perspective</span>》<span lang="EN-US"><a href="http://www.linuxjournal.com/article/6345?page=0,0">http://www.linuxjournal.com/article/6345?page=0,0</a><br /></span>《<span lang="EN-US">Efficient data transfer through zero copy</span>》<span lang="EN-US"><a href="http://www.ibm.com/developerworks/linux/library/j-zerocopy">http://www.ibm.com/developerworks/linux/library/j-zerocopy</a><br /></span>《<span lang="EN-US">The C10K problem</span>》<span lang="EN-US"><a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></span></strong></p></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/12/13/post/">AWK学习笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-13T00:00:00+08:00" pubdate data-updated="true">Dec 13<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/12/13/post/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>
</p><p><em>by BoBo</em></p>
<p><em></em><br /><strong><span>一点历史</span></strong><br />&nbsp;&nbsp;&nbsp; AWK上世纪70年代诞生于传奇的Bell实验室，名字取于它的三位发明人，Alfred Aho, Peter Weinberger和 Brian Kernighan名字的首字母。发音类似《The AWK Programing Language》封面上的海雀（一种海鸟）的英文发音(auck[ɔ:k])。AWK最早出现在Unix V7中，Linux诞生后，AWK被LSB纳入其中，这意味者所有的Linux发行版都会提供awk的实现。目前linux上广发使用的是GNU实现的gawk，此外还有nawk，mawk，pgawk等版本。这些实现在AWK的语言规范基础上，扩展了一些其他功能，本文只关心最基础最通用的AWK规范，不探究相关实现的具体实现区别，欲知详情，请查看相关实现的手册。<br />以下是其中一位创始人Alfred V.Aho对AWK的描述。<br />&nbsp;&nbsp;&nbsp;&nbsp;<em>AWK is a language for processing files of text. A file is treated as a sequence of records, and by default each line is a record. Each line is broken up into a sequence of fields, so we can think of the first word in a line as the first field, the second word as the second field, and so on. An AWK program is of a sequence of pattern-action statements. AWK reads the input a line at a time. A line is scanned for each pattern in the program, and for each pattern that matches, the associated action is executed.&amp;quot; - Alfred V.Aho</em><br />尊重原文，不翻译。<br /><br /><strong><span>瞟一眼</span></strong><br />准备一份数据文件datafile<br /><br />Nike	green	X	10	10.00<br />Nike	blue	XL	10	10.00<br />Nike	red	 L	10	12.00<br />Adiddas	yellow	L	10	10.00<br />Adiddas	brown	M	10	10.00<br />Adiddas	gray	M	20	8.00<br /><br />打开终端，执行<br /><br /><span><span><strong>awk &#8216;/Nike/ {print $2}&#8217; datafile</strong><br /></span></span><br />输出<br /><br />green<br />blue<br />red<br /><br />解释下:<br />awk表示AWK解析器命令<br />两个&#8217;之间的部分表示这次执行的命令行脚本,其中/Nike/叫模式pattern,{print $2}叫操作action，print表示打印，$2表示每一记录中的第2个域。<br />datafile表示输入文件。<br />整个命令的意思表示：<br />对datafile中所有匹配Nike的行，执行print $2操作，打印含有Nike行中的第二个被空白符隔开的字段。<br />晕了么？来看点概念的解释吧:)<br /><br /><strong><span>一些枯燥的概念</span></strong><br /><strong>输入文件：</strong>待处理的数据文件datafile，每个输入文件为多个记录的集合<br /><strong>记录分割符：</strong>将输入文件划分为多个记录的符号，默认为&#8217;/n&#8217;<br /><strong>记录：</strong>默认数据文件中的每一行，如&amp;quot;Nike&nbsp;&nbsp;&nbsp; green&nbsp;&nbsp; X&nbsp;&nbsp; 10&nbsp; 10.00&amp;quot;，每个记录是多个域的集合<br /><strong>域分隔符：</strong>将每个记录划分为多个域的符号，默认为空白符<br /><strong>域：</strong>记录被域分割符划分后的单元，每个输入文件中的最小处理单元。如Nike， green，X，10，10.00分别为第一个记录的第1，2，3，4，5个域（注意，这里不是从0开始计数的）<br /><strong>Buffer：</strong>AWK中支持两种Buffer，域buffer和记录buffer<br />record buffer:表示整条记录，可以通过$0获取<br />field buffer:当前记录中的每一个field，可以通过$1,$2,$3获取。<br /><strong>内置变量：</strong><br />FS:Field separator，域分隔符，默认为空白符<br />RS:Record Separator，记录分隔符，默认为换行符<br />NF:Number of Fields in current record，当前记录中的域数<br />NR:Number of the current Record，当前的记录数<br />OFS:Output Field Separator，输出域分隔符，默认为空白符<br />ORS:Output Record Separator，输出记录分隔符，默认为换行符<br />FILENAME: Current filename，当前输入文件名<br /><br />针对一个awk命令行</p>
<p><span><span><strong>awk &#8216;pattern {action}&#8217; datafile</strong></span></span><br />awk的执行流程：<br />1.读取：awk会按行读取输入文件(Line by Line)<br />2.切分：将输入行划分为多个域<br />3.匹配：根据pattern匹配<br />4.执行：对匹配的行执行action<br /><br /><strong><span>命令行</span></strong><br />AWK的命令行语法有两种形式</p>
<p><br />awk [options] -f program-file file&#8230;<br />awk [options] &#8216;program-text&#8217; file&#8230;</p>
<p><br />前者通过-f参数指定使用后面的名为program-file的文件作为AWK脚本处理输入文件file<br />后者表示 program-text是一段AWK命令行脚本，用于处理输入文件file.<br />options表示参数可选项，具体参数列表请参考相关手册。<br />基本语法：<br />当通过awk [options] &#8216;program-text&#8217; file&#8230;方式执行awk时，program-text表示一段脚本。AWK的命令行脚本由模式和操作两部分组成：<br />pattern {action}，表示对输入文件中所有匹配pattern的行，执行action操作。<br />缺少pattern时，默认对输入文件中所有行执行action<br />缺少action时，默认向标准输出打印所有匹配pattern的行<br />两者都没有时，不进行任何操作。</p>
<p><br /><strong><span>例子：</span></strong><br />awk &#8216;/for/ {print $1}&#8217;<strong>&nbsp;&nbsp; &nbsp;</strong>datafile 表示打印datafile中所有匹配含有for的行的第一个域（关于域，请看下文）<br />awk &#8216;/for/&#8217; &nbsp; &nbsp;datafile 表示打印datafile中所有包含for的行<br />awk &#8216;{print}&#8217; &nbsp; &nbsp;datafile 表示打印datafile中所有行<br /><br /><strong><span>模式pattern:</span></strong></p>
<p><strong></strong>pattern分为Simple pattern和Range pattern两大类。<br /><strong><span>Simple Pattern</span></strong>包括：<br />a.BEGIN:标示对输入文件进行处理之前<br />b.END:标示对输入文件完成处理之后<br />c.EXPRESSION:表达式，包括正则表达式，算数表达式，逻辑表达式<br />d.NOTHING:什么都没有，表示无pattern，默认匹配所有行<br /><strong>Expression Pattern：</strong><br />正则表达式/regx/：<br />通过两个/标记的pattern为正则表达式，如/^bi/匹配所有以bi开始的记录，正则表达式语法与grep语法类似，不再赘述，请查看相关手册。<br />需要注意的是 ~/regx/表示不匹配，如~/^bi/表示不是以bi开始的所有记录。<br />算数表达式：<br />模式$3*$4&amp;gt;100 表示匹配所有$3与$4的积大于100的记录，类似的算数操作符还包括：<br />逻辑表达式：<br />模式 $NR&amp;gt;2 &amp;amp;&amp;amp; /^bi/ 表示匹配所有行数大于2以bi开头的的行， &amp;amp;&amp;amp;表示逻辑与<br /><br /><strong><span>Range Pattern</span></strong><br />Range Pattern用于匹配输入行中一个连续的区域，其语法由两个Simple Pattern构成：<br />pattern1, pattern2 {action}<br />pattern1表示从第一个匹配pattern1的行开始，执行action操作。<br />pattern2表示从第一个匹配pattern2的行开始，停止执行action操作。<br /><strong><span>例子：</span></strong><br /><br /><span>awk &#8216;/blue/,/yellow/ {print}&#8217; datafile</span></p>
<p><br />表示从datafile中第一匹配blue的行开始执行print操作，打印整行，到第一个匹配yellow的行为止，停止打印。<br /><br /><span>awk &#8216;$NR==2, $NR==10 {print}&#8217; datafile</span><br /><br />表示打印datafile中的第2～10行。<br /><br /><strong><span>操作Action</span></strong><br />Action语句分为：表达式，输出，判断，循环，和控制语句。<br /><strong><span>表达式</span></strong><br />作为一门编程语言，AWK与其他语言一样，有变量，运算符，可以进行表达式计算。<br /><strong><span>变量</span></strong><br />AWK是弱类型的，变量无须声明，且第一次引用后就一直存在。所有的变量都被初始化为空字符串。变量名必须以字母开头，可以包含字母，数字和下划线。AWK支持三类变量，数字，字符串，数组。<br />需要特殊说明的是数组，数组只支持一维，且索引可以是数字也可以是字符串（因此我更倾向于它是个map）。可以通过<br /><br />delete arr[index]<br /><br />删除数组arr中index元素<br /><br /><strong><span>赋值操作符</span></strong><br />=	 assign result of right-hand-side expression to left-hand-side variable<br />++	Add 1 to variable<br />&#8211;	 Subtract 1 from variable<br />+=	Assign result of addition<br />-=	 Assign result of subtraction<br />*=	 Assign result of multiplication<br />/=	 Assign result of division<br />%=	Assign result of modulo<br />^=	 Assign result of exponentiation<br /><strong><span>输出语句</span></strong><br />AWK中有三种用于输出的内置函数：<br />print	 直接输出到终端<br />printf	 格式化输出到终端（与C中的printf类似）<br />sprintf	 格式化字符串（与C中不同的是，通过返回值方式返回新的字符串）<br />可以通过输出重定向将输出打印到其他地方：<br />&amp;gt; &amp;quot;file&amp;quot;	清空file，并打印输出到file<br />&amp;gt;&amp;gt; &amp;quot;file&amp;quot;	将输出追加到file末尾<br />| &amp;quot;command&amp;quot;	管道符，将输出作为command命令的输入。<br /><br /><strong><span>条件判断</span></strong><br /><strong>if-else语法：</strong><br /><br />if (条件语句)<br />执行语句1<br />else<br />执行语句2<br /><br /><strong>例子:</strong><br /><br /><span>if(NR&lt;3)<br />print $2<br />else<br />print $3</span><br /><br /><span>循环</span><br /><strong><span>for循环</span></strong><br /><strong>语法<br /></strong><br />for(初始条件;限制条件;条件更新)<br />执行语句<br /><br /><strong>例子</strong><br /><br /><span>for(i=1; i&lt;NR; i++)<br />{<br />total +=$i;<br />count++<br />}</span><br /><br /><span><strong>do-while循环</strong></span><br /><strong>语法</strong><br /><br />do<br />执行语句<br />while(条件)<br /><br /><strong>例子</strong><br /><br /><span>i=1<br />do {<br />print $0<br />i++<br />} while (i&lt;=10)</span><br /><br />AWK同样支持break,continue两个循环控制语句。<br /><br /><span><strong>脚本编程</strong></span><br />上文主要讲述了命令行下，AWK可以进行操作的基本知识，事实上，AWK作为一种编程语言，可以独立写成脚本文件，采用<br /><br /><span>awk [options] -f script-file inputfile&#8230;</span><br /><br />的方式执行。<br />通常一个awk包含三段式基本结构<br /><br />&#8212;&#8212;&#8211;BEGIN区&#8212;&#8212;&#8212;-<br />|	BEGIN {初始化操作 } |<br />&#8212;&#8212;&#8211;命令执行&#8212;&#8212;&#8212;-<br />|	pattern	{action} &nbsp; &nbsp; &nbsp; |<br />|	&#8230;<br />|	pattern	{action} &nbsp; &nbsp; &nbsp; |<br />&#8212;&#8212;&#8212;END区&#8212;&#8212;&#8212;&#8211;<br />|	EDN &nbsp;{结尾操作} &nbsp; &nbsp; &nbsp; |<br />&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />BEGIN语句进行文件处理前的初始化操作，如定义FS，定义变量值等。该语句在一次文件处理过程中只在处理前执行一次<br />中间的命令执行是对每一个输入记录都进行的操作，语法与上述的基础语法一样<br />END区只在文件处理完成后执行一次。<br />例子<br /><br /><span><span>BEGIN { FS=: }<br />/for/ {print $2}<br />END {print &#8220;this is end!&#8221; }</span><br /></span><br />先定义域分隔符为&#8221;:&#8221;，然后对所有匹配for的记录，打印第2个域，文件处理完后打印&#8221;this is end!&#8221;<br /><br /><span><span><strong>内置函数</strong></span></span><br />AWK提供一些内置函数。<br />字符串内置函数：<br />sub (regex, substr), 使用substr替换匹配自左向右做大匹配regex的部分。<br />gsub (regex,substr), 与sub类似，只是在全文中进行替换<br />length(string), 获取string字符串的长度<br />toupper(string), 将string转换为大写<br />tolower(string), 将string转换为小写<br />split(string, array, field separator), 将string以field separator为分隔符分割为数组存储到array中。<br />以上只是常用的一些内置函数，其他请参考相关手册<br /><br /><span><strong>示例</strong></span><br />分析日志，现有一份日志pic.log，格式如下，需要提取出其中的url链接<br /><br />INFO 10/18/2010 00:00:05&#8211;offerId=[836952303]. url=[http://f7.images22.51img1.com/6000/hw3255311/7205a450f1ea2751f31aa8c3ad1dd2be.jpg].<br />INFO 10/18/2010 00:00:05&#8211;offerId=[836952303]. url=[http://fb.images22.51img1.com/6000/hw3255311/bfe077567231f7d8efae4a1ac1b19477.jpg].<br />INFO 10/18/2010 00:00:05&#8211;offerId=[836952303]. url=[http://f6.images22.51img1.com/6000/hw3255311/6106d6366351d32c68e3f8a332b52da9.jpg].<br />INFO 10/18/2010 00:00:05&#8211;offerId=[836952303]. url=[http://f6.images22.51img1.com/6000/hw3255311/6106d6366351d32c68e3f8a332b52da9.jpg].<br /><br /><strong><span>脚本</span></strong><br /><br /><span>awk -F &#8220;[&#8221; &#8216;{split($3, url, &#8220;]&#8221;);print url[1]}&#8217; pic.log</span><br /><br />通过 -F &#8220;:&#8221;定义域分隔符为&#8221;[&#8220;,这样每行数据会被划分为三个域<br /><br />INFO 10/18/2010 00:00:05&#8211;offerId=	&#8211;[&#8211; 836952303]. url=	&#8211;[&#8211; http://f7.images22.51img1.com/6000/hw3255311/7205a450f1ea2751f31aa8c3ad1dd2be.jpg].<br /><br />所需要提取的url位于第三个域中，通过内置函数<br /><br /><span>split($3, url, &#8220;]&#8221;)</span><br /><br />将第三个域以&#8221;]&#8221;分割，存储到url数组中，url数组为[&#8220;http://f7.images22.51img1.com/6000/hw3255311/7205a450f1ea2751f31aa8c3ad1dd2be.jpg&#8221;, &#8220;.&#8221;]<br />url[1]即为所需的url<br /><br /><strong><span>参考资料</span></strong><br />a. man awk<br />b. AWK wiki，http://en.wikipedia.org/wiki/AWK<br />c.《AWK学习笔记》http://man.lupaworld.com/content/manage/ringkee/awk.htm</p></div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/16/">&larr; Older</a>
    
    <a href="archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/14/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <ul id="recent_posts">
      <li class="post">
      <a href="http://jiangbo.me" alt="Home"><img src="/images/Home.png"></a>
      <a href="http://jiangbo.me/archives/" alt="Archives"><img src="/images/Calendar.png"></a>
      <a href="mailto:" alt="E-Mail"><img src="/images/Envelope.png"></a>
      <a href="http://jiangbo.me/atom.xml" alt="subscribe feed"><img src="/images/rss.png"></a>
      </li>
  </ul>
</section>
<section>
<a href="/about-me/"><h1>关于我</h1></a>
  <p>一个非纯种程序员，爱代码爱旅行爱美女</p>
  <iframe width="100%" height="480" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=480&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=1&isFans=0&uid=1892066397&verifier=8c17d4b5&dpc=1"></iframe>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/12/21/hdfs-raid/">HDFS RAID</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/10/hdfs-blockreaderlocal/">HDFS-2246:使用BlockReaderLocal优化本地block读取</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/23/mount-hdfs-with-fuse-dfs/">使用FUSE-DFS mount HDFS</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/18/hdfs-dataxceiver/">HDFS源码学习（15）——DataXceiverServer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/18/hdfs-client-code/">HDFS源码学习（14）——Client代码结构</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/jiang-bo">@jiang-bo</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jiang-bo',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/blog/categories/android' style='font-size: 116.66666666666667%'>Android</a> <a href='/blog/categories/design' style='font-size: 110.0%'>Design</a> <a href='/blog/categories/hadoop' style='font-size: 103.33333333333333%'>Hadoop</a> <a href='/blog/categories/hdfs' style='font-size: 160.0%'>HDFS</a> <a href='/blog/categories/java' style='font-size: 103.33333333333333%'>Java</a> <a href='/blog/categories/javaee' style='font-size: 116.66666666666667%'>JavaEE</a> <a href='/blog/categories/jvm' style='font-size: 110.0%'>JVM</a> <a href='/blog/categories/linux' style='font-size: 140.0%'>Linux</a> <a href='/blog/categories/mac' style='font-size: 113.33333333333333%'>Mac</a> <a href='/blog/categories/pattern' style='font-size: 110.0%'>Pattern</a> <a href='/blog/categories/python' style='font-size: 103.33333333333333%'>Python</a> <a href='/blog/categories/ruby' style='font-size: 103.33333333333333%'>Ruby</a> <a href='/blog/categories/ruby' style='font-size: 106.66666666666667%'>ruby</a> <a href='/blog/categories/spring' style='font-size: 103.33333333333333%'>Spring</a> <a href='/blog/categories/velocity源码分析' style='font-size: 106.66666666666667%'>Velocity源码分析</a> <a href='/blog/categories/webx' style='font-size: 103.33333333333333%'>webx</a> <a href='/blog/categories/基础巩固' style='font-size: 103.33333333333333%'>基础巩固</a> <a href='/blog/categories/嵌入式开发' style='font-size: 113.33333333333333%'>嵌入式开发</a> <a href='/blog/categories/技术生活' style='font-size: 106.66666666666667%'>技术生活</a> <a href='/blog/categories/未分类' style='font-size: 110.0%'>未分类</a> <a href='/blog/categories/生活' style='font-size: 103.33333333333333%'>生活</a> <a href='/blog/categories/高性能服务器' style='font-size: 103.33333333333333%'>高性能服务器</a> </span>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - jiang-bo -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F85545761b56f725733aef53ca8e6f717' type='text/javascript'%3E%3C/script%3E"));
</script>


</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'jiangbo';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
