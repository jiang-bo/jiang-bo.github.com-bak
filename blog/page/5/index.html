
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>非纯种程序猿</title>
  <meta name="author" content="jiang-bo">

  
  <meta name="description" content="一、简介 一个实际的应用系统难免会出现问题。JVM能够实时的记录系统发生问题时JVM内部的运行状态，并将起存储在堆转储（Heap dump）文件中，dump文件为系统分析提供了重要依据。但是原始dump文件纯文本方式，难于理解，为了降低dump文件分析的复杂度，MAT（Eclipse Memory &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jiangbo.me/blog/page/5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="非纯种程序猿" type="application/atom+xml">
  <!-- font-family: 'Knewave', cursive; -->
<link href='http://fonts.googleapis.com/css?family=Knewave' rel='stylesheet' type='text/css'>
<!-- font-family: 'Cantata One', serif; -->
<link href='http://fonts.googleapis.com/css?family=Cantata+One' rel='stylesheet' type='text/css'>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34477986-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1>
      <a href="/">非纯种程序猿</a>
      
  </h1>
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jiangbo.me" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about-me">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/02/use-mat-analysis-dump-file/">使用MAT进行dump文件分析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-02T00:00:00+08:00" pubdate data-updated="true">Aug 2<span>nd</span>, 2011</time>
        
         | <a href="/blog/2011/08/02/use-mat-analysis-dump-file/#disqus_thread">Comments</a>
        
        
          | 

<span class="categories">
  
    <a class='category' href='/blog/categories/未分类/'>未分类</a>
  
</span>


        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>一、简介</strong></p>

<p><strong> </strong>一个实际的应用系统难免会出现问题。JVM能够实时的记录系统发生问题时JVM内部的运行状态，并将起存储在堆转储（Heap dump）文件中，dump文件为系统分析提供了重要依据。但是原始dump文件纯文本方式，难于理解，为了降低dump文件分析的复杂度，MAT（Eclipse Memory Analyzer）应运而生。MAT时公认的、强大的、“傻瓜式”堆转储文件分析工具。详细介绍见<a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a></p>

<p><strong>二、获取MAT</strong></p>

<p>MAT现在提供两种安装方式，Eclipse IDE插件（集成版）和Eclipse RCP（单机版）。</p>

<p>本文采用的时Eclipse RCP版本，可到<a href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/downloads.php</a>下载。解压运行后如图所示</p>

<p><a href="/images/uploads/2011/07/界面.png"><img class="alignnone size-large wp-image-21" title="界面" src="/images/uploads/2011/07/界面-1024x673.png" alt="" width="640" height="420" /></a></p>

<p>&nbsp;</p>

<p><strong>三、获取dump文件</strong></p>

<p>可用通过多种方式获得dump文件，主要分为交互式和基于事件的方式。</p>

<p><strong> 1.交互式</strong></p>

<p>1）、使用Ctrl+Break：如果在JVM运行时参数上加入
<p style="text-align: center;">-Xrunhprof:format=b,file=heapdump.hprof</p>
参数。当java进程收到SIGQUIT信号（kill -3）时会生成一个HPROF格式的dump文件。</p>

<p>2）、使用jmap工具：jmap是jdk自带的实用工具，在java6可以通过如下命令获得一个运行中java进程的dump文件
<p style="text-align: center;">jmap -dump:format=b,file=<em>filename pid</em></p>
<strong> 2.基于事件的方法</strong></p>

<p>通常在生产环境中当出现问题时再去用交互式的方式获取dump文件为时已晚。因此实际的生产环境多用基于事件的方法。JVM支持在发生OutOfMemoryError时进行自动的堆转储，生成dump文件。需要在应用JVM启动参数中加入如下参数：
<p style="text-align: center;">-XX:+HeapDumpOnOutOfMemoryError</p>
<strong>四、文件分析</strong></p>

<p>在MAT钟打开获取的转储文件，文件夹在完成后自动生成分析报告，如图所示</p>

<p><a href="/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.23.47-PM.png"><img class="alignnone size-large wp-image-29" title="文件分析" src="/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.23.47-PM-1024x640.png" alt="" width="640" height="400" /></a></p>

<p>主工作区展示文件分析的概况，可以看到主要的类占用（Biggest Objects）和可选的一些操作，Action，Reports等。</p>

<p><a href="/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.23.56-PM.png"><img class="alignnone size-full wp-image-30" title="action" src="/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.23.56-PM.png" alt="" width="917" height="193" /></a></p>

<p>左侧的Inspector区可以查看各个类的域信息，如图显示的是一个com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate类实例的信息，包括其各个域的值。</p>

<p><strong>五、一个OutOfMemoryError小例子</strong></p>

<p><strong> 1.写一个明显会OutOfMemoryError小程序</strong></p>

<p>&nbsp;</p>

<p>import java.util.Date;</p>

<p>import java.util.List;</p>

<p>import java.util.ArrayList;</p>

<p>public class Test{</p>

<p>public static void main(String[] args){</p>

<p>List&lt;Date&gt; list = new ArrayList&lt;Date&gt;();</p>

<p>while(true){</p>

<p>Date date = new Date();</p>

<p>list.add(date);</p>

<p>date=null;</p>

<p>}</p>

<p>&nbsp;</p>

<p>}</p>

<p>}</p>

<p><strong> 2.设置启动参数</strong>
<p style="text-align: center;">$ java -XX:+HeapDumpOnOutOfMemoryError Test</p>
<strong> 3.如其获得异常</strong></p>

<p><a href="/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.29.07-PM.png"><img class="alignnone size-full wp-image-31" title="Screen shot 2011-07-29 at 3.29.07 PM" src="/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.29.07-PM.png" alt="" width="534" height="130" /></a></p>

<p>生成的dump文件为java_pid4931.hprof</p>

<p><strong> 4.使用MAT导入dump文件</strong></p>

<p><a href="/images/uploads/2011/08/dump文件.png"><img class="aligncenter size-full wp-image-32" title="dump文件" src="/images/uploads/2011/08/dump文件.png" alt="" width="1356" height="858" /></a></p>

<p>从分析报告中可以明显看出有一个类Thread占用了99%的内存，该类由java.lang.ClassLoader加载。</p>

<p>通过查看Leak Suspects报告可以看到更清晰的内存泄漏情况</p>

<p><a href="/images/uploads/2011/07/Leak-Suspects.png"><img class="aligncenter size-large wp-image-24" title="Leak Suspects" src="/images/uploads/2011/07/Leak-Suspects-1024x647.png" alt="" width="640" height="404" /></a></p>

<p>点击detail，可以查看详细信息</p>

<p><a href="/images/uploads/2011/07/详细信息.png"><img class="aligncenter size-large wp-image-23" title="详细信息" src="/images/uploads/2011/07/详细信息-1024x636.png" alt="" width="640" height="397" /></a> 跟集合到内存消耗点的最短路径</p>

<p><a href="/images/uploads/2011/07/最短路径.png"><img class="aligncenter size-full wp-image-22" title="最短路径" src="/images/uploads/2011/07/最短路径.png" alt="" width="593" height="195" /></a></p>

<p>内存消耗的对象</p>

<p><a href="/images/uploads/2011/07/内存消耗对象.png"><img class="aligncenter size-full wp-image-26" title="内存消耗对象" src="/images/uploads/2011/07/内存消耗对象.png" alt="" width="553" height="373" /></a></p>

<p>此时应该就可以分析出大概情况了，内存溢出主要是因为还有大量的Date对象。进而查看下线程栈</p>

<p><a href="/images/uploads/2011/07/Thread.png"><img class="aligncenter size-full wp-image-25" title="Thread" src="/images/uploads/2011/07/Thread.png" alt="" width="852" height="171" /></a></p>

<p>也就基本能定位问题的所在了。问题代码就是：</p>

<p>while(true){</p>

<p>Date date = new Date();</p>

<p>list.add(date);</p>

<p>date=null;</p>

<p>}</p>

<p><strong>六、总结</strong></p>

<p>MAT是一个功能强大的内存分析工具，目前介绍的只是很基本的一些功能，更多信息请参考</p>

<p><a href="http://memoryanalyzer.blogspot.com">http://memoryanalyzer.blogspot.com</a>/</p>

<p><a href="http://www.ibm.com/developerworks/cn/java/j-memoryanalyzer/index.html?ca=drs-">http://www.ibm.com/developerworks/cn/java/j-memoryanalyzer/index.html?ca=drs-</a></p>

<p><a href="http://www.vogella.de/articles/EclipseMemoryAnalyser/article.html">http://www.vogella.de/articles/EclipseMemoryAnalyser/article.html</a></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/15/post/">Mac OSX安装Git</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-15T00:00:00+08:00" pubdate data-updated="true">Mar 15<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/03/15/post/#disqus_thread">Comments</a>
        
        
          | 

<span class="categories">
  
    <a class='category' href='/blog/categories/mac/'>Mac</a>
  
</span>


        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>一、安装Git</strong></p>
<p class="p2"><span class="s1">由于mac git的地址<a href="http://code.google.com/p/git-osx-installer/"><span class="s2">http://code.google.com/p/git-osx-installer/</span></a>被墙，被迫使用源码安装，源码可以从<a href="http://kernel.org/pub/software/scm/git/"><span class="s2">http://kernel.org/pub/software/scm/git/</span></a></span><span class="s3">下载，编译源码需要先安装xcode，参考<a href="http://developer.apple.com/"><span class="s4">http://developer.apple.com</span></a>。</span></p>
<p class="p3">编译安装</p>
<p class="p3">1.解压</p>
<p class="p3">&nbsp;&nbsp; &nbsp;&nbsp;tar xjvf git-1.7.4.1.tar.tar.bz2</p>
<p class="p3">2. 编译</p>
<p class="p3">&nbsp;&nbsp; &nbsp;&nbsp;cd git-1.7.4.1</p>
<p class="p3">&nbsp;&nbsp; &nbsp;&nbsp;./configure &#8211;prefix=/usr/local</p>
<p class="p3">&nbsp;&nbsp; &nbsp;&nbsp;make</p>
<p class="p3">3.安装</p>
<p class="p3">&nbsp;&nbsp; &nbsp;&nbsp;sudo make install</p>
<p class="p4">&nbsp;</p>
<p class="p3">Ok 了，which git试一下～</p>
<p class="p5"><strong>二、设置SSH</strong></p>
<p class="p3">github使用SSH链接，需要设置SSH</p>
<p class="p3">1.检查SSH key</p>
<p class="p3">&nbsp;&nbsp; &nbsp; cd ~/.ssh</p>
<p class="p3">2.备份已有的key，（如果有的话）</p>
<p class="p3">&nbsp;&nbsp; &nbsp; mkdir key_backup</p>
<p class="p3">&nbsp;&nbsp; &nbsp; mv id_rsa* key_backup</p>
<p class="p3">3.生成SSH key</p>
<p class="p3">$ ssh-keygen -t rsa -C <a href="mailto:jiang.bo.hit@gmail.com"><span class="s5">jiang.bo.hit@gmail.com</span></a></p>
<p class="p3">Generating public/private rsa key pair.</p>
<p class="p3">Enter file in which to save the key (/Users/jiangbo/.ssh/id_rsa):&nbsp;</p>
<p class="p3">Enter passphrase (empty for no passphrase):</p>
<p class="p3">Enter same passphrase again:</p>
<p class="p3">Your identification has been saved in yes.</p>
<p class="p3">Your public key has been saved in id_rsa.pub.</p>
<p class="p3">The key fingerprint is:</p>
<p class="p3">fb:c4:b0:e0:47:fd:be:e0:fb:ea:73:ef:a8:29:d5:22 <a href="mailto:jiang.bo.hit@gmail.com"><span class="s5">jiang.bo.hit@gmail.com</span></a></p>
<p class="p3">The key&#8217;s randomart image is:</p>
<p class="p3">+&#8211;[ RSA 2048]&#8212;-+</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . S ..&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp; . oE=o..&nbsp;&nbsp;&nbsp; |</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . +o+..&nbsp;&nbsp;&nbsp; |</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..+.+..&nbsp;&nbsp; |</p>
<p class="p3">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oOB=+o&nbsp; |</p>
<p class="p3">+&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;+</p>
<p class="p3">4.将SSH key添加到GitHub</p>
<p class="p3">登录到GitHub页面，Account Settings-&gt;SSH Public Keys-&gt;Add another key</p>
<p class="p3">将生成的key(id_rsa.pub文件）内容copy到输入框中，save。</p>
<p class="p4"><img src="http://hi.csdn.net/attachment/201103/15/0_1300170843sWhI.gif" alt="" /></p>
<p class="p3">5.测试链接</p>
<p class="p6"><span class="s3">$ ssh <a href="mailto:git@github.com"><span class="s5">git@github.com</span></a></span></p>
<p class="p3">The authenticity of host &#8217;<a href="http://github.com/"><span class="s5">github.com</span></a> (207.97.227.239)&#8217; can&#8217;t be established.</p>
<p class="p3">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</p>
<p class="p3">Are you sure you want to continue connecting (yes/no)? yes</p>
<p class="p4">&nbsp;</p>
<p class="p3">PTY allocation request failed on channel 0</p>
<p class="p3">Hi jiang-bo! You&#8217;ve successfully authenticated, but GitHub does not provide shell access.</p>
<p class="p3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Connection to <a href="http://github.com/"><span class="s5">github.com</span></a> closed.</p>
<p class="p3">别担心，这是正常情况。</p>
<p class="p5"><strong>三、设置个人信息</strong></p>
<p class="p3">$ git config &#8211;global <a href="http://user.name/"><span class="s5">user.name</span></a> &#8220;Bo Jiang&#8221;</p>
<p class="p3">$ git config &#8211;global user.email &#8220;jiang.bo.hit@gmail.com&#8221;</p>
<p class="p3">&nbsp;</p>
<p>&nbsp;</p></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/10/post/">Java基础（1）－泛型</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-10T00:00:00+08:00" pubdate data-updated="true">Mar 10<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/03/10/post/#disqus_thread">Comments</a>
        
        
          | 

<span class="categories">
  
    <a class='category' href='/blog/categories/基础巩固/'>基础巩固</a>
  
</span>


        
      </p>
    
  </header>


  <div class="entry-content"><p>&nbsp;</p>
<h2>一、Basic FAQ：</h2>
<p><strong>1. What are Java Generics?</strong></p>
<p>&nbsp;&nbsp; &nbsp; <em>Java泛型是什么？</em></p>
<p>&nbsp;&nbsp; &nbsp; Java Generics ara language feature that allows for definition and use of generic types and methods.</p>
<p>&nbsp;&nbsp; &nbsp; <em>Java泛型指的是一种允许定义通用类型和方法的语言特性。</em></p>
<p><strong>2. What is the primary purpose of Java Generics?</strong></p>
<p>&nbsp;&nbsp; &nbsp; <em>Java泛型最初的目的是什么？</em></p>
<p>&nbsp;&nbsp; &nbsp; Java Generics are invented primarily for implementation of generic collection.</p>
<p>&nbsp;&nbsp; &nbsp; <em>Java泛型最初是为了实现通用集合类设计的。</em></p>
<p><strong>3.What is the benefit of using Java generics?</strong></p>
<p>&nbsp;&nbsp; &nbsp; <em>使用Java泛型的好处？？？</em></p>
<p>&nbsp;&nbsp; &nbsp; Early error detection at compile time.</p>
<p>&nbsp;&nbsp; &nbsp; <em>能够在编译期检查类型错误。</em></p>
<p><strong>4.What does type-safe mean?</strong></p>
<p>&nbsp;&nbsp; &nbsp; <em>什么叫做类型安全</em>？</p>
<p>&nbsp;&nbsp; &nbsp; In Java, a program is considered type-safe if it compiles without errors and warnings and does not raise any unexpected ClassCastException at runtime.</p>
<p><em>&nbsp;&nbsp; &nbsp; 在Java里，类型安全指的是：如果一个程序编译期未发现Error或Warning，那么在运行时就不会报ClassCastException。</em></p>
<p>&nbsp;</p>
<h2>奇怪的特性</h2>
<p>&nbsp;&nbsp; &nbsp; 泛型有些特性，令人困扰，如下：</p>
<p>&nbsp;</p>
<ol>
<li>&nbsp;&nbsp; 子类型的泛型不能赋值给父类型的泛型，即泛型不可协变。</li>
<li>&nbsp;&nbsp; 泛型类并没有自己独有的Class类对象。比如并不存在List&lt;String&gt;.class或是List&lt;Integer&gt;.class，而只有List.class。</li>
<li>&nbsp;&nbsp; 静态变量是被泛型类的所有实例所共享的。对于声明为MyClass&lt;T&gt;的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass&lt;String&gt;还是new MyClass&lt;Integer&gt;创建的对象，都是共享一个静态变量。</li>
<li>&nbsp;&nbsp; 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException&lt;String&gt;和MyException&lt;Integer&gt;的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。</li>
</ol>
<p>&nbsp;</p>
<h2>协变（convariant）</h2>
<p>&nbsp;&nbsp; &nbsp; Within the type system of a programming language, covariance and contravariance refers to the ordering of types from narrower to wider and their interchangeability or equivalence in certain situations (such as parameters, generics, and return types). &nbsp; &nbsp; &mdash;&mdash;Wikipedia（偶不会翻译*A*）</p>
<p>&nbsp;&nbsp; &nbsp; 简单来说，可协变表示子类型的引用可以赋值给父类性，不可协变则表示子类型引用不能赋值给父类型。以数组和泛型为例：</p>
<p>&nbsp;&nbsp; &nbsp; 数组是可协变的，因为Number[] a = new Integer[]()；是成立的。</p>
<p>&nbsp;&nbsp; &nbsp; 泛型是不可协变的，因为List&lt;Number&gt; ln = new ArrayList&lt;Integer&gt;()；编译会出错。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; 由于数组是可协变的，而泛型不可协变，导致数组能够协变而泛型不能协变的另一个后果是，不能实例化泛型类型的数组（new List&lt;String&gt;[3]是不合法的），除非类型参数是一个未绑定的通配符（new List&lt;?&gt;[3]是合法的）。</p>
<p>&nbsp;&nbsp; &nbsp;可是，为什么泛型不能协变呢？&mdash;&mdash;因为这样会破坏类型安全</p>
<p>&nbsp;&nbsp; &nbsp; 假设可以协变，那么</p>
<p>&nbsp;&nbsp; &nbsp; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();</p>
<p>&nbsp;&nbsp; &nbsp; List&lt;Number&gt; ln = li;</p>
<p>&nbsp;&nbsp; &nbsp; ln.add(new Float(3.14));</p>
<p>&nbsp;&nbsp; &nbsp; 发生了什么？本来是放Integer的List里面加入了Float！。</p>
<p>&nbsp;</p>
<h2>类型擦除</h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List&lt;Object&gt;和List&lt;String&gt;等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</p>
<h3>编译器如何处理泛型？</h3>
<p>&nbsp;&nbsp; &nbsp; 通常情况下，一个编译器处理泛型有两种方式：</p>
<p>&nbsp;&nbsp; &nbsp; 1.Code specialization。在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型list，可能需要针对string，integer，float产生三份目标代码。</p>
<p>&nbsp;&nbsp; &nbsp; 2.Code sharing。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。</p>
<p>&nbsp;&nbsp; &nbsp; C++中的模板（template）是典型的Code specialization实现。C++编译器会为每一个泛型类实例生成一份执行代码。执行代码中integer list和string list是两种不同的类型。这样会导致代码膨胀（code bloat），不过有经验的C＋＋程序员可以有技巧的避免代码膨胀。</p>
<p>&nbsp;&nbsp; &nbsp; Code specialization另外一个弊端是在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针。没必要为每个类型都产生一份执行代码。而这也是Java编译器中采用Code sharing方式处理泛型的主要原因。</p>
<p>&nbsp;&nbsp; &nbsp; Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</p>
<h3>什么是类型擦除？</h3>
<p>&nbsp;&nbsp; &nbsp; 类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。</p>
<p>&nbsp;&nbsp; &nbsp; 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。</p>
<p>&nbsp;&nbsp; &nbsp; 类型擦除的主要过程如下：</p>
<p>&nbsp;&nbsp; &nbsp; 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</p>
<p>&nbsp;&nbsp; &nbsp; 2.移除所有的类型参数。</p>
<p>&nbsp;&nbsp; &nbsp; 如</p>
<p><pre class="brush: java">interface Comparable &lt;A&gt; { 
  public int compareTo( A that); 
} 
final class NumericValue implements Comparable &lt;NumericValue&gt; { 
  priva te byte value;  
  public  NumericValue (byte value) { this.value = value; }    
  public  byte getValue() { return value; }    
  public  int compareTo( NumericValue t hat) { return this.value - that.value; } 
} 
－－－－－－－－－－－－－－－－－
class Collections {  
  public static &lt;A extends Comparable&lt;A&gt;&gt;A max(Collection &lt;A&gt; xs) { 
    Iterator &lt;A&gt; xi = xs.iterator(); 
    A w = xi.next(); 
    while (xi.hasNext()) { 
      A x = xi.next(); 
      if (w.compareTo(x) &lt; 0) w = x; 
    } 
    return w; 
  } 
} 
final class Test { 
  public static void main (String[ ] args) { 
    LinkedList &lt;NumericValue&gt; numberList = new LinkedList &lt;NumericValue&gt; (); 
    numberList .add(new NumericValue((byte)0));  
    numberList .add(new NumericValue((byte)1));  
    NumericValue y = Collections.max( numberList );  
  } 
}</pre>&nbsp;</p>
<p>经过类型擦除后的类型为</p>
<p><pre class="brush: java">     interface Comparable { 
  public int compareTo( Object that); 
} 
final class NumericValue implements Comparable { 
  priva te byte value;  
  public  NumericValue (byte value) { this.value = value; }  
  public  byte getValue() { return value; }  
  public  int compareTo( NumericValue t hat)   { return this.value - that.value; } 
  public  int compareTo(Object that) { return this.compareTo((NumericValue)that);  } } 
－－－－－－－－－－－－－
class Collections {  
  public static Comparable max(Collection xs) { 
    Iterator xi = xs.iterator(); 
    Comparable w = (Comparable) xi.next(); 
    while (xi.hasNext()) { 
      Comparable x = (Comparable) xi.next(); 
      if (w.compareTo(x) &lt; 0) w = x; 
    } 
    return w; 
  } 
} 
final class Test { 
  public static void main (String[ ] args) { 
    LinkedList numberList = new LinkedList(); 
    numberList .add(new NumericValue((byte)0));  ，
    numberList .add(new NumericValue((byte)1));  
    NumericValue y = (NumericValue) Collections.max( numberList );  
  } 
}</pre>&nbsp;</p>
<p>&nbsp;</p>
<p>第一个泛型类Comparable &lt;A&gt;擦除后 A被替换为最左边界Object。Comparable&lt;NumericValue&gt;的类型参数NumericValue被擦除掉，但是这直接导致NumericValue没有实现接口Comparable的compareTo(Object that)方法，于是编译器充当好人，添加了一个桥接方法。</p>
<p>第二个示例中限定了类型参数的边界&lt;A extends Comparable&lt;A&gt;&gt;A，A必须为Comparable&lt;A&gt;的子类，按照类型擦除的过程，先讲所有的类型参数ti换为最左边界Comparable&lt;A&gt;，然后去掉参数类型A，得到最终的擦除后结果。</p>
<h3>类型擦除带来的问题</h3>
<p>&nbsp;&nbsp; &nbsp; 正是由于类型擦除的隐蔽存在，直接导致了众多的泛型灵异问题。</p>
<p><strong>Q1.用同一泛型类的实例区分方法签名？&mdash;&mdash;NO！</strong></p>
<p>{code}</p>
<p>import java.util.*;</p>
<p>&nbsp;</p>
<p>public class Erasure{</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;public void test(List&lt;String&gt; ls){</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;System.out.println(&#8220;Sting&#8221;);</p>
<p>&nbsp;&nbsp; &nbsp;}</p>
<p>&nbsp;&nbsp; &nbsp;public void test(List&lt;Integer&gt; li){</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;System.out.println(&#8220;Integer&#8221;);</p>
<p>&nbsp;&nbsp; &nbsp;}</p>
<p>}</p>
<p>{code}</p>
<p>编译该类，</p>
<p><img src="http://hi.csdn.net/attachment/201103/10/0_12997506095504.gif" alt="" /></p>
<p>what the f**k! 参数类型明明不一样啊，一个List&lt;String&gt;，一个是List&lt;Integer&gt;，但是，偷偷的说，type erasure之后，它就都是List了⋯⋯</p>
<p><strong>Q2. 同时catch同一个泛型异常类的多个实例？&mdash;&mdash;NO！</strong></p>
<p>同理，如果定义了一个泛型一场类GenericException&lt;T&gt;，千万别同时catch GenericException&lt;Integer&gt; 和GenericException&lt;String&gt;，因为他们是一样一样滴⋯⋯</p>
<p><strong>Q3.泛型类的静态变量是共享的？&mdash;&mdash;Yes！</strong></p>
<p>猜猜这段代码的输出是什么？</p>
<p><pre class="brush: java">import java.util.*;
public class StaticTest{
    public static void main(String[] args){
        GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;();
        gti.var=1;
        GT&lt;String&gt; gts = new GT&lt;String&gt;();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT&lt;T&gt;{
    public static int var=0;
    public void nothing(T x){}
}</pre>&nbsp;</p>
<p>答案是&mdash;&mdash;2！</p>
<p>&nbsp;</p>
<h3>Just remember：</h3>
<p>1.虚拟机中没有泛型，只有普通类和普通方法</p>
<p>2.所有泛型类的类型参数在编译时都会被擦除</p>
<p>3.创建泛型对象时请指明类型，让编译器尽早的做参数检查（Effective Java，第23条：请不要在新代码中使用原生态类型）</p>
<p>4.不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>参考文档</h2>
<p>《Java深度历险－泛型》http://www.infoq.com/cn/articles/cf-java-generics</p>
<p>《Java Generics FAQ》http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</p>
<p>《Java Gotchas》http://www.ibm.com/developerworks/java/library/j-jtp01255.html</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/02/27/post/">使用memcached进行并发控制</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-02-27T00:00:00+08:00" pubdate data-updated="true">Feb 27<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/02/27/post/#disqus_thread">Comments</a>
        
        
          | 

<span class="categories">
  
    <a class='category' href='/blog/categories/javaee/'>JavaEE</a>
  
</span>


        
      </p>
    
  </header>


  <div class="entry-content"><p><strong><span style="font-family: mceinline;">引子</span></strong></p>
<p>
</p><p class="p2">一个使用缓存进行并发控制的讨论，让我学习到成本与收益间的平衡，以及何为真正的可用性&#8230;&#8230;</p>
<p class="p2">防止并发有多种方式，本文只涉及使用缓存memcached控制。</p>
<p class="p1" style="font-weight: bold;"><span style="font-family: mceinline;"><strong>并发场景</strong><span class="s1"><strong>：</strong></span></span></p>
<p class="p2"><strong>&nbsp;&nbsp; </strong>&nbsp; 用例：SNS系统中具有高级会员资格的人发起活动。</p>
<p class="p2">&nbsp;&nbsp; &nbsp; 业务规则：1.一个人同时只能创建一个活动。2.具有高级会员资格。</p>
<p class="p2">&nbsp;&nbsp; &nbsp; 基本流程如下：</p>
<p style="font-weight: bold;">&nbsp;</p>
<p class="p1" style="font-weight: bold;">&nbsp;</p>

<p>&nbsp;</p>
<p class="p2"><img src="http://hi.csdn.net/attachment/201102/27/0_1298804115LLTM.gif" alt="" /></p>
<p class="p1">这个流程中存在明显的并发问题，当进程A校验过会员M有资格，并且为创建过活动，但为开始执行创建操作，此时另一个进程B也进行了规则判断，顺利通过，并完成创建操作，此时A继续执行，则会产生两条M的活动。（这个并发场景很简单，很普遍）</p>
<p class="p2"><strong><span style="font-family: mceinline;">最初的解决方案：</span></strong></p>
<p class="p1">&nbsp;&nbsp; &nbsp; 计划利用memcached的add操作的原子性来控制并发，具体方式如下：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 1.申请锁：在校验是否创建过活动前，执行add操作key为memberId，如果add操作失败，则表示有另外的进程在并发的为该memberId创建活动，返回创建失败。否则表示无并发</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 2.执行创建活动</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 3.释放锁：创建活动完成后，执行delete操作，删除该memberId。</p>
<p class="p2"><strong><span style="font-family: mceinline;">问题：</span></strong></p>
<p class="p1"><strong>&nbsp;&nbsp; &nbsp;</strong> 如此实现存在一些问题：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 1.memcached中存放的值有有效期，即过期后自动失效，如add过M1后，M1失效，可以在此add成功</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 2.即使通过配置，可以使memcached永久有效，即不设有效期，memcached有容量限制，当容量不够后会进行自动替换，即有可能add过M1后，M1被其他key值置换掉，则再次add可以成功。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 3.此外，memcached是基于内存的，掉电后数据会全部丢失，导致重启后所有memberId均可重新add。</p>
<p class="p2"><strong><span style="font-family: mceinline;">应对问题：</span></strong></p>
<p class="p1">&nbsp;&nbsp; &nbsp; 针对上述的几个问题，根本原因是add操作有时效性，过期，被替换，重启，都会是原来的add操作失效。解决该问题有两个方法：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 1.采用持久化的缓存解决方法，如TT（<span class="s1">Tokyo Tyrant：</span><span class="s2">http://fallabs.com/tokyotyrant/</span>）</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 2.减轻时效性的影响，使用memcached CAS（check and set）方式。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 第一种不必解释了，很简单，原来的所有问题都是时效性惹得祸，时效性源于memcached是基于内存的，那么采用持久话存储的TT可以彻底根治这个问题。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 第二种方式需要简单介绍下：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; memcached中除了add操作是原子的，还有另外两个操作也是原子的：incr和decr，使用CAS模式即：</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 1.预先在memcached中设置一个key值，假设为CREATKEY＝1</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 2.每次创建活动时，在规则校验前先get出CREATEKEY＝x；</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 3.进行规则校验</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 4.执行incr CREATEKEY操作，检验返回值是否为所期望的x＋1，如果不是，则说明在此期间有另外的进程执行了incr操作，即存在并发，放弃更新。否则</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 5.执行创建活动</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 对比这两种方法，从效果上看可以发现第一种时100％可靠的，不存在问题；第二种，可能存在误判，即本来不存在并发，却被判为并发，如缓存重启，或key值失效后，incr值可能不同于期望值，导致误判。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 但是从成本上考虑，TT是持久化的缓存解决方案，完美意味着高成本，我们必须维护持久化数据，而使用memcached的CAS方式，可以以几乎0成本的方式解决时效性问题，尽管存在一点小缺陷，但这种缺陷可以通过简单的重试即可解决。考虑实际的产出比，采用memcached的CAS方式更适合实际情况。</p>
<p class="p1">&nbsp;&nbsp; &nbsp; 成本与收益间的平衡，做科学与做工程的区别～</p>
<p class="p3">&nbsp;</p>
<p class="p1">&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/01/17/post/">Zero-Copy&amp;sendfile浅析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-17T00:00:00+08:00" pubdate data-updated="true">Jan 17<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/01/17/post/#disqus_thread">Comments</a>
        
        
          | 

<span class="categories">
  
    <a class='category' href='/blog/categories/高性能服务器/'>高性能服务器</a>
  
</span>


        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>一、典型<span lang="EN-US">IO</span>调用的问题</strong><span lang="EN-US"><br /></span>一个典型的<span lang="EN-US">web</span>服务器传送静态文件（如<span lang="EN-US">CSS</span>，<span lang="EN-US">JS</span>，图片等）的过程如下：<span lang="EN-US"><br /><em><br />read(file, tmp_buf, len);<br />write(socket, tmp_buf, len);</em><br /><br /></span>首先调用<span lang="EN-US">read</span>将文件从磁盘读取到<span lang="EN-US">tmp_buf</span>，然后调用<span lang="EN-US">write</span>将<span lang="EN-US">tmp_buf</span>写入到<span lang="EN-US">socket</span>，在这过程中会出现四次数据<span lang="EN-US"> copy</span>，过程如图<span lang="EN-US">1</span>所示</p>
<p style="text-align: center;"><img src="http://hi.csdn.net/attachment/201101/17/0_12952361353NK2.gif" alt="" /></p>
<p style="text-align: center;">图1</p>
<p style="text-align: left;">&nbsp;</p>
<p><span lang="EN-US">1</span><span>。当调用</span><span lang="EN-US">read</span><span>系统调用时，通过</span><span lang="EN-US">DMA</span><span>（</span><span lang="EN-US">Direct Memory Access</span><span>）将数据</span><span lang="EN-US">copy</span><span>到内核模式</span><span lang="EN-US"><br /></span><span lang="EN-US">2</span><span>。然后由</span><span lang="EN-US">CPU</span><span>控制将内核模式数据</span><span lang="EN-US">copy</span><span>到用户模式下的</span><span lang="EN-US"> buffer</span><span>中</span><span lang="EN-US"><br /></span><span lang="EN-US">3</span><span>。</span><span lang="EN-US">read</span><span>调用完成后，</span><span lang="EN-US">write</span><span>调用首先将用户模式下</span><span lang="EN-US"> buffer</span><span>中的数据</span><span lang="EN-US">copy</span><span>到内核模式下的</span><span lang="EN-US">socket buffer</span><span>中</span><span lang="EN-US"><br /></span><span lang="EN-US">4</span><span>。最后通过</span><span lang="EN-US">DMA copy</span><span>将内核模式下的</span><span lang="EN-US">socket buffer</span><span>中的数据</span><span lang="EN-US">copy</span><span>到网卡设备中传送。</span></p>
<p><span><span>从上面的过程可以看出，数据白白从内核模式到用户模式走了一</span><span> </span><span>圈，浪费了两次</span><span lang="EN-US">copy</span><span>，而这两次</span><span lang="EN-US">copy</span><span>都是</span><span lang="EN-US">CPU copy</span><span>，即占用</span><span lang="EN-US">CPU</span><span>资源。</span></span></p>
<p>&nbsp;</p>
<p><strong><span lang="EN-US">二、Zero-Copy&amp;Sendfile()</span></strong><span lang="EN-US"><br /></span><span lang="EN-US">Linux 2.1</span><span>版本内核引入了</span><span lang="EN-US">sendfile</span><span>函数，用于将文件通过</span><span lang="EN-US">socket</span><span>传送。</span><span lang="EN-US"><br /></span><em><span lang="EN-US">sendfile(socket, file, len);</span></em><span lang="EN-US"><br /></span><span>该函数通过一次系统调用完成了文件的传送，减少了原来</span><span lang="EN-US"> read/write</span><span>方式的模式切换。此外更是减少了数据的</span><span lang="EN-US">copy</span><span>，</span><span lang="EN-US">sendfile</span><span>的详细过程图</span><span lang="EN-US">2</span><span>所示：</span></p>
<p style="text-align: center;"><span><img src="http://hi.csdn.net/attachment/201101/17/0_1295236150Tf0Z.gif" alt="" /></span></p>
<p style="text-align: center;"><span>图2</span></p>
<p style="text-align: left;"><span><span>通过</span><span lang="EN-US">sendfile</span><span>传送文件只需要一次系统调用，当调用</span><span lang="EN-US"> sendfile</span><span>时：</span><span lang="EN-US"><br /></span><span lang="EN-US">1</span><span>。首先通过</span><span lang="EN-US">DMA copy</span><span>将数据从磁盘读取到</span><span lang="EN-US">kernel buffer</span><span>中</span><span lang="EN-US"><br /></span><span lang="EN-US">2</span><span>。然后通过</span><span lang="EN-US">CPU copy</span><span>将数据从</span><span lang="EN-US">kernel buffer copy</span><span>到</span><span lang="EN-US">sokcet buffer</span><span>中</span><span lang="EN-US"><br /></span><span lang="EN-US">3</span><span>。最终通过</span><span lang="EN-US">DMA copy</span><span>将</span><span lang="EN-US">socket buffer</span><span>中数据</span><span lang="EN-US">copy</span><span>到网卡</span><span lang="EN-US">buffer</span><span>中发送</span><span lang="EN-US"><br /></span><span lang="EN-US">sendfile</span><span>与</span><span lang="EN-US">read/write</span><span>方式相比，少了</span><span> </span><span>一次模式切换一次</span><span lang="EN-US">CPU copy</span><span>。但是从上述过程中也可以发现从</span><span lang="EN-US">kernel buffer</span><span>中将数据</span><span lang="EN-US">copy</span><span>到</span><span lang="EN-US">socket buffer</span><span>是没必要的。</span></span></p>
<p style="text-align: left;"><span><span><span>为此，</span><span lang="EN-US">Linux2.4</span><span>内核对</span><span lang="EN-US">sendfile</span><span>做了改进，如图</span><span lang="EN-US">3</span><span>所示</span></span></span></p>
<p style="text-align: center;"><span><span><span><img src="http://hi.csdn.net/attachment/201101/17/0_1295236158Tr8t.gif" alt="" /></span></span></span></p>
<p style="text-align: center;">图3</p>
<p style="text-align: left;">改进后的处理过程如下：<span lang="EN-US"><br />1</span>。<span lang="EN-US">DMA copy</span>将磁盘数据<span lang="EN-US">copy</span>到<span lang="EN-US">kernel buffer</span>中<span lang="EN-US"><br />2</span>。向<span lang="EN-US">socket buffer</span>中追加当前要发送的数据在<span lang="EN-US">kernel buffer</span>中的位置和偏移量<span lang="EN-US"><br />3</span>。<span lang="EN-US">DMA gather copy</span>根据<span lang="EN-US">socket buffer</span>中的位置和偏移量直接将<span lang="EN-US">kernel buffer</span>中的数据<span lang="EN-US">copy</span>到网卡上。<span lang="EN-US"><br /></span>经过上述过程，数据只经过了<span lang="EN-US">2</span>次<span lang="EN-US">copy</span>就从磁盘传送出去了。<span lang="EN-US"><br /></span>（可能有人要纠结<span lang="EN-US">&ldquo;</span>不是说<span lang="EN-US">Zero</span>－<span lang="EN-US">Copy</span>么？怎么还有两次<span lang="EN-US">copy</span>啊<span lang="EN-US">&rdquo;</span>，事实上这个<span lang="EN-US">Zero copy</span>是针对内核来讲的，数据在内核模式下是<span lang="EN-US">Zero</span>－<span lang="EN-US">copy</span>的。话说回来，文件本身在瓷盘上要真是完全<span lang="EN-US">Zero</span>－<span lang="EN-US">copy</span>就能传送，那才见鬼了 呢）。<span lang="EN-US"><br /></span>当前许多高性能<span lang="EN-US">http server</span>都引入了<span lang="EN-US">sendfile</span>机制，如<span lang="EN-US">nginx</span>，<span lang="EN-US">lighttpd</span>等。<span lang="EN-US"><br /><br /><strong>三、Java NIO</strong></span><strong>中的<span lang="EN-US">transferTo()</span></strong><span lang="EN-US"><br />Java NIO</span>中<span lang="EN-US"><br /><em>FileChannel.transferTo(long position, long count, WriteableByteChannel target)</em><br /></span>方法将当前通道中的数据传送到目标通道<span lang="EN-US">target</span>中，在支持<span lang="EN-US">Zero-Copy</span>的<span lang="EN-US">linux</span>系统中，<span lang="EN-US">transferTo()</span>的实现依赖于<span lang="EN-US"> sendfile()</span>调用。</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><strong>四、参考文档<span lang="EN-US"><br /></span>《<span lang="EN-US">Zero Copy I: User-Mode Perspective</span>》<span lang="EN-US"><a href="http://www.linuxjournal.com/article/6345?page=0,0">http://www.linuxjournal.com/article/6345?page=0,0</a><br /></span>《<span lang="EN-US">Efficient data transfer through zero copy</span>》<span lang="EN-US"><a href="http://www.ibm.com/developerworks/linux/library/j-zerocopy">http://www.ibm.com/developerworks/linux/library/j-zerocopy</a><br /></span>《<span lang="EN-US">The C10K problem</span>》<span lang="EN-US"><a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></span></strong></p></div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/6/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/4/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="first odd">
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/08/31/something-about-memcache-internal/">关于Memcache内存管理模型的理解</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/04/08/build-fluent-interface-with-method-chain-and-static-factory/">使用方法链和静态工厂构造流畅接口</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/21/java-lang-instrument/">java.lang.instrument笔记</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/14/jetty-classloader/">Jetty ClassLoader解析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/13/unzip-file-from-win-to-mac/">解决Mac上解压Windows压缩包乱码问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/10/jvm-luncher-lifecycle/">JVM Luncher Lifecycle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/10/compile-openjdk7-on-centos6/">CentOS6编译OpenJDK7</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/04/how-to-get-ip-and-send-to-gtalk-by-ruby/">如何用ruby获取本机IP&发送給Gtalk</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/12/31/my2011and2012/">我的2011&2012</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/12/17/rails_new_optimize_bundle_install/">优化rails new时bundle install速度</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/jiang-bo">@jiang-bo</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jiang-bo',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - jiang-bo -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> and <a href="https://github.com/gluttony/object-octopress-theme">Object</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'jiangbo';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
